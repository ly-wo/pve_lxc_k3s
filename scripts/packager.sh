#!/bin/bash
# PVE LXC K3s Template Packager
# 模板打包脚本，生成 LXC 模板格式并压缩

set -euo pipefail

# 脚本配置
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
CONFIG_FILE="${PROJECT_ROOT}/config/template.yaml"
LOG_DIR="${PROJECT_ROOT}/logs"
BUILD_DIR="${PROJECT_ROOT}/.build"
OUTPUT_DIR="${PROJECT_ROOT}/output"

# 创建必要的目录
mkdir -p "$LOG_DIR" "$OUTPUT_DIR"

# 日志配置
LOG_FILE="${LOG_DIR}/packager.log"
PACKAGE_LOG="${LOG_DIR}/package-$(date +%Y%m%d-%H%M%S).log"

# 日志函数
log() {
    local level="$1"
    local message="$2"
    local timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE" | tee -a "$PACKAGE_LOG"
}

log_info() { log "INFO" "$1"; }
log_warn() { log "WARN" "$1"; }
log_error() { log "ERROR" "$1"; }
log_debug() { 
    if [[ "${DEBUG:-false}" == "true" ]]; then
        log "DEBUG" "$1"
    fi
}

# 错误处理
error_exit() {
    local error_message="$1"
    local exit_code="${2:-1}"
    log_error "$error_message"
    log_error "打包失败，退出码: $exit_code"
    cleanup_on_error
    exit "$exit_code"
}

# 错误时清理
cleanup_on_error() {
    log_info "执行错误清理..."
    
    # 清理临时文件
    rm -rf "${OUTPUT_DIR}/temp" || true
    
    log_info "错误清理完成"
}

# 信号处理
trap 'error_exit "打包过程被中断" 130' INT TERM

# 加载配置
load_configuration() {
    log_info "加载配置文件"
    
    if [[ ! -f "$CONFIG_FILE" ]]; then
        error_exit "配置文件不存在: $CONFIG_FILE"
    fi
    
    # 使用 yq 或简单的 grep/awk 解析 YAML
    if command -v yq >/dev/null 2>&1; then
        TEMPLATE_NAME=$(yq eval '.template.name' "$CONFIG_FILE" 2>/dev/null || echo "alpine-k3s")
        TEMPLATE_VERSION=$(yq eval '.template.version' "$CONFIG_FILE" 2>/dev/null || echo "1.0.0")
        TEMPLATE_DESCRIPTION=$(yq eval '.template.description' "$CONFIG_FILE" 2>/dev/null || echo "Alpine Linux LXC template with pre-installed K3s")
        TEMPLATE_AUTHOR=$(yq eval '.template.author' "$CONFIG_FILE" 2>/dev/null || echo "PVE LXC K3s Template Generator")
        BASE_IMAGE=$(yq eval '.template.base_image' "$CONFIG_FILE" 2>/dev/null || echo "alpine:3.18")
        ARCHITECTURE=$(yq eval '.template.architecture' "$CONFIG_FILE" 2>/dev/null || echo "amd64")
        K3S_VERSION=$(yq eval '.k3s.version' "$CONFIG_FILE" 2>/dev/null)
    else
        # 简单的 grep/awk 解析作为后备方案
        TEMPLATE_NAME=$(grep -A 10 "^template:" "$CONFIG_FILE" | grep "name:" | awk '{print $2}' | tr -d '"' || echo "alpine-k3s")
        TEMPLATE_VERSION=$(grep -A 10 "^template:" "$CONFIG_FILE" | grep "version:" | awk '{print $2}' | tr -d '"' || echo "1.0.0")
        TEMPLATE_DESCRIPTION=$(grep -A 10 "^template:" "$CONFIG_FILE" | grep "description:" | awk -F': ' '{print $2}' | tr -d '"' || echo "Alpine Linux LXC template with pre-installed K3s")
        TEMPLATE_AUTHOR=$(grep -A 10 "^template:" "$CONFIG_FILE" | grep "author:" | awk -F': ' '{print $2}' | tr -d '"' || echo "PVE LXC K3s Template Generator")
        BASE_IMAGE=$(grep -A 10 "^template:" "$CONFIG_FILE" | grep "base_image:" | awk '{print $2}' | tr -d '"' || echo "alpine:3.18")
        ARCHITECTURE=$(grep -A 10 "^template:" "$CONFIG_FILE" | grep "architecture:" | awk '{print $2}' | tr -d '"' || echo "amd64")
        K3S_VERSION=$(grep -A 10 "^k3s:" "$CONFIG_FILE" | grep "version:" | awk '{print $2}' | tr -d '"\n')
    fi
    
    # 验证必要配置
    if [[ -z "$K3S_VERSION" ]]; then
        error_exit "K3s 版本未在配置中指定"
    fi
    
    log_info "配置加载完成:"
    log_info "  模板名称: $TEMPLATE_NAME"
    log_info "  模板版本: $TEMPLATE_VERSION"
    log_info "  系统架构: $ARCHITECTURE"
    log_info "  K3s版本: $K3S_VERSION"
}

# 验证构建结果
verify_build_output() {
    log_info "验证构建输出"
    
    if [[ ! -d "$BUILD_DIR" ]]; then
        error_exit "构建目录不存在: $BUILD_DIR"
    fi
    
    if [[ ! -d "${BUILD_DIR}/rootfs" ]]; then
        error_exit "根文件系统不存在: ${BUILD_DIR}/rootfs"
    fi
    
    # 检查关键文件
    local critical_files=(
        "${BUILD_DIR}/rootfs/usr/local/bin/k3s"
        "${BUILD_DIR}/rootfs/etc/lxc-template-info"
    )
    
    for file in "${critical_files[@]}"; do
        if [[ ! -f "$file" ]]; then
            error_exit "关键文件不存在: $file"
        fi
    done
    
    log_info "构建输出验证通过"
}

# 创建 LXC 模板元数据
create_template_metadata() {
    log_info "创建 LXC 模板元数据"
    
    local metadata_dir="${OUTPUT_DIR}/temp/metadata"
    mkdir -p "$metadata_dir"
    
    # 创建模板配置文件
    cat > "${metadata_dir}/config" << EOF
# LXC Template Configuration
# Generated by PVE LXC K3s Template Generator

# Template Information
lxc.template.name = $TEMPLATE_NAME
lxc.template.version = $TEMPLATE_VERSION
lxc.template.description = $TEMPLATE_DESCRIPTION
lxc.template.author = $TEMPLATE_AUTHOR
lxc.template.architecture = $ARCHITECTURE

# Container Configuration
lxc.arch = $ARCHITECTURE
lxc.include = /usr/share/lxc/config/common.conf

# Network Configuration
lxc.net.0.type = veth
lxc.net.0.link = lxcbr0
lxc.net.0.flags = up
lxc.net.0.hwaddr = 00:16:3e:xx:xx:xx

# Mount Configuration
lxc.mount.auto = proc:mixed sys:ro cgroup:mixed
lxc.mount.entry = /sys/fs/fuse/connections sys/fs/fuse/connections none bind,optional 0 0

# Security Configuration
lxc.apparmor.profile = generated
lxc.apparmor.allow_nesting = 1
lxc.seccomp.profile = /usr/share/lxc/config/common.seccomp

# Resource Limits (can be overridden by PVE)
lxc.cgroup2.memory.max = 2G
lxc.cgroup2.cpu.max = 200000 100000

# K3s Specific Configuration
lxc.cap.drop = 
lxc.cap.keep = sys_admin sys_resource
lxc.mount.entry = /lib/modules lib/modules none bind,ro 0 0

# Startup Configuration
lxc.start.auto = 0
lxc.start.delay = 0
lxc.start.order = 100
EOF

    # 创建模板信息文件
    cat > "${metadata_dir}/template" << EOF
#!/bin/bash
# LXC Template Script for $TEMPLATE_NAME
# This script is called by LXC when creating containers from this template

set -euo pipefail

# Template Information
TEMPLATE_NAME="$TEMPLATE_NAME"
TEMPLATE_VERSION="$TEMPLATE_VERSION"
TEMPLATE_DESCRIPTION="$TEMPLATE_DESCRIPTION"
TEMPLATE_AUTHOR="$TEMPLATE_AUTHOR"
ARCHITECTURE="$ARCHITECTURE"
K3S_VERSION="$K3S_VERSION"

# Function to display template information
template_info() {
    cat << INFO
Template: \$TEMPLATE_NAME
Version: \$TEMPLATE_VERSION
Description: \$TEMPLATE_DESCRIPTION
Author: \$TEMPLATE_AUTHOR
Architecture: \$ARCHITECTURE
K3s Version: \$K3S_VERSION
INFO
}

# Function to create container from template
template_create() {
    local name="\$1"
    local path="\$2"
    local rootfs="\$path/rootfs"
    local config="\$path/config"
    
    echo "Creating LXC container '\$name' from template '\$TEMPLATE_NAME'"
    
    # Extract rootfs
    if [[ -f "\$path/../rootfs.tar.gz" ]]; then
        echo "Extracting rootfs..."
        mkdir -p "\$rootfs"
        tar -xzf "\$path/../rootfs.tar.gz" -C "\$rootfs"
    else
        echo "ERROR: rootfs.tar.gz not found"
        return 1
    fi
    
    # Generate container-specific configuration
    cat >> "\$config" << CONTAINER_CONFIG

# Container-specific configuration for \$name
lxc.uts.name = \$name
lxc.rootfs.path = dir:\$rootfs

# K3s specific mounts and capabilities
lxc.mount.entry = tmpfs dev/shm tmpfs defaults 0 0
lxc.mount.entry = mqueue dev/mqueue mqueue defaults 0 0

CONTAINER_CONFIG
    
    echo "Container '\$name' created successfully"
    echo "To start K3s after container boot, run: lxc-attach -n \$name -- systemctl start k3s"
}

# Function to clean up template
template_clean() {
    local path="\$1"
    echo "Cleaning up template files in \$path"
    rm -rf "\$path/rootfs"
}

# Main template script logic
case "\${1:-}" in
    info)
        template_info
        ;;
    create)
        template_create "\$2" "\$3"
        ;;
    clean)
        template_clean "\$2"
        ;;
    *)
        echo "Usage: \$0 {info|create|clean}"
        echo "  info                    - Display template information"
        echo "  create <name> <path>    - Create container from template"
        echo "  clean <path>            - Clean up template files"
        exit 1
        ;;
esac
EOF

    chmod +x "${metadata_dir}/template"
    
    # 创建模板清单文件
    cat > "${metadata_dir}/manifest.json" << EOF
{
  "template": {
    "name": "$TEMPLATE_NAME",
    "version": "$TEMPLATE_VERSION",
    "description": "$TEMPLATE_DESCRIPTION",
    "author": "$TEMPLATE_AUTHOR",
    "architecture": "$ARCHITECTURE",
    "created": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
    "base_image": "$BASE_IMAGE",
    "k3s_version": "$K3S_VERSION"
  },
  "files": {
    "rootfs": "rootfs.tar.gz",
    "config": "config",
    "template_script": "template",
    "manifest": "manifest.json"
  },
  "checksums": {},
  "size": {
    "compressed": 0,
    "uncompressed": 0
  },
  "features": [
    "kubernetes",
    "k3s",
    "container-runtime",
    "networking",
    "security-hardened"
  ],
  "requirements": {
    "lxc_version": ">=3.0.0",
    "kernel_version": ">=4.15",
    "memory_min": "512M",
    "storage_min": "2G"
  },
  "ports": [
    {
      "port": 6443,
      "protocol": "tcp",
      "description": "K3s API Server"
    },
    {
      "port": 10250,
      "protocol": "tcp",
      "description": "Kubelet API"
    },
    {
      "port": 8472,
      "protocol": "udp",
      "description": "Flannel VXLAN"
    }
  ]
}
EOF
    
    log_info "模板元数据创建完成"
}

# 创建根文件系统压缩包
create_rootfs_archive() {
    log_info "创建根文件系统压缩包"
    
    local temp_dir="${OUTPUT_DIR}/temp"
    local rootfs_archive="${temp_dir}/rootfs.tar.gz"
    
    # 计算未压缩大小
    local uncompressed_size
    uncompressed_size=$(du -sb "${BUILD_DIR}/rootfs" | cut -f1)
    
    log_info "根文件系统大小: $(numfmt --to=iec $uncompressed_size)"
    
    # 创建压缩包
    log_info "压缩根文件系统..."
    
    # 使用 tar 创建压缩包，排除不需要的文件
    if ! tar -czf "$rootfs_archive" \
        --exclude='./dev/*' \
        --exclude='./proc/*' \
        --exclude='./sys/*' \
        --exclude='./tmp/*' \
        --exclude='./run/*' \
        --exclude='./var/cache/apk/*' \
        --exclude='./var/log/*' \
        --exclude='./root/.cache' \
        -C "${BUILD_DIR}/rootfs" .; then
        error_exit "根文件系统压缩失败"
    fi
    
    # 计算压缩后大小
    local compressed_size
    compressed_size=$(stat -c%s "$rootfs_archive")
    
    log_info "压缩完成:"
    log_info "  未压缩大小: $(numfmt --to=iec $uncompressed_size)"
    log_info "  压缩后大小: $(numfmt --to=iec $compressed_size)"
    log_info "  压缩比: $(( (uncompressed_size - compressed_size) * 100 / uncompressed_size ))%"
    
    # 更新清单文件中的大小信息
    local manifest_file="${temp_dir}/metadata/manifest.json"
    if command -v jq >/dev/null 2>&1; then
        jq --argjson compressed "$compressed_size" \
           --argjson uncompressed "$uncompressed_size" \
           '.size.compressed = $compressed | .size.uncompressed = $uncompressed' \
           "$manifest_file" > "${manifest_file}.tmp" && mv "${manifest_file}.tmp" "$manifest_file"
    fi
}

# 计算文件校验和
calculate_checksums() {
    log_info "计算文件校验和"
    
    local temp_dir="${OUTPUT_DIR}/temp"
    local manifest_file="${temp_dir}/metadata/manifest.json"
    
    # 计算各文件的 SHA256 校验和
    local checksums_json="{"
    
    for file in rootfs.tar.gz metadata/config metadata/template metadata/manifest.json; do
        if [[ -f "${temp_dir}/$file" ]]; then
            local checksum
            checksum=$(sha256sum "${temp_dir}/$file" | cut -d' ' -f1)
            local filename=$(basename "$file")
            checksums_json+='"'$filename'":"'$checksum'",'
            log_debug "校验和 $filename: $checksum"
        fi
    done
    
    # 移除最后的逗号并关闭 JSON
    checksums_json="${checksums_json%,}}"
    
    # 更新清单文件
    if command -v jq >/dev/null 2>&1; then
        jq --argjson checksums "$checksums_json" \
           '.checksums = $checksums' \
           "$manifest_file" > "${manifest_file}.tmp" && mv "${manifest_file}.tmp" "$manifest_file"
    fi
    
    log_info "校验和计算完成"
}

# 创建最终模板包
create_template_package() {
    log_info "创建最终模板包"
    
    local temp_dir="${OUTPUT_DIR}/temp"
    local template_filename="${TEMPLATE_NAME}-${TEMPLATE_VERSION}-${ARCHITECTURE}.tar.gz"
    local template_package="${OUTPUT_DIR}/$template_filename"
    
    # 创建模板包结构
    local package_dir="${temp_dir}/package"
    mkdir -p "$package_dir"
    
    # 复制文件到包目录
    cp "${temp_dir}/rootfs.tar.gz" "$package_dir/"
    cp -r "${temp_dir}/metadata"/* "$package_dir/"
    
    # 创建包信息文件
    cat > "${package_dir}/README.txt" << EOF
# $TEMPLATE_NAME LXC Template

## Template Information
- Name: $TEMPLATE_NAME
- Version: $TEMPLATE_VERSION
- Description: $TEMPLATE_DESCRIPTION
- Author: $TEMPLATE_AUTHOR
- Architecture: $ARCHITECTURE
- K3s Version: $K3S_VERSION
- Build Date: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

## Installation Instructions

1. Extract this template package to your LXC templates directory:
   tar -xzf $template_filename -C /var/lib/vz/template/cache/

2. Create a new container using this template:
   pct create <VMID> local:vztmpl/$template_filename

3. Start the container:
   pct start <VMID>

4. Access the container:
   pct enter <VMID>

5. Check K3s status:
   systemctl status k3s

## Features
- Pre-installed K3s Kubernetes distribution
- Security hardened Alpine Linux base
- Optimized for container environments
- Ready-to-use Kubernetes cluster
- Minimal resource footprint

## Network Ports
- 6443/tcp: K3s API Server
- 10250/tcp: Kubelet API
- 8472/udp: Flannel VXLAN

## Requirements
- LXC version >= 3.0.0
- Kernel version >= 4.15
- Minimum 512MB RAM
- Minimum 2GB storage

## Support
For issues and documentation, visit:
https://github.com/your-repo/pve-lxc-k3s-template

EOF
    
    # 创建最终压缩包
    log_info "打包模板文件..."
    
    if ! tar -czf "$template_package" -C "$package_dir" .; then
        error_exit "模板包创建失败"
    fi
    
    # 计算最终包大小
    local package_size
    package_size=$(stat -c%s "$template_package")
    
    log_info "模板包创建完成:"
    log_info "  文件名: $template_filename"
    log_info "  大小: $(numfmt --to=iec $package_size)"
    log_info "  路径: $template_package"
    
    # 创建校验和文件
    sha256sum "$template_package" > "${template_package}.sha256"
    log_info "校验和文件: ${template_package}.sha256"
}

# 生成发布信息
generate_release_info() {
    log_info "生成发布信息"
    
    local release_info="${OUTPUT_DIR}/release-info.json"
    local template_filename="${TEMPLATE_NAME}-${TEMPLATE_VERSION}-${ARCHITECTURE}.tar.gz"
    local template_package="${OUTPUT_DIR}/$template_filename"
    local package_size
    package_size=$(stat -c%s "$template_package")
    
    cat > "$release_info" << EOF
{
  "release": {
    "tag_name": "v$TEMPLATE_VERSION",
    "name": "$TEMPLATE_NAME v$TEMPLATE_VERSION",
    "body": "## $TEMPLATE_NAME v$TEMPLATE_VERSION\\n\\n### Features\\n- Pre-installed K3s $K3S_VERSION\\n- Security hardened Alpine Linux\\n- Optimized for PVE LXC containers\\n- Ready-to-use Kubernetes cluster\\n\\n### Installation\\n\`\`\`bash\\n# Download template\\nwget https://github.com/your-repo/pve-lxc-k3s-template/releases/download/v$TEMPLATE_VERSION/$template_filename\\n\\n# Create container\\npct create <VMID> local:vztmpl/$template_filename\\n\\n# Start container\\npct start <VMID>\\n\`\`\`\\n\\n### Checksums\\n- SHA256: \$(cat ${template_package}.sha256 | cut -d' ' -f1)\\n\\n### Requirements\\n- LXC >= 3.0.0\\n- Kernel >= 4.15\\n- RAM >= 512MB\\n- Storage >= 2GB",
    "draft": false,
    "prerelease": false
  },
  "assets": [
    {
      "name": "$template_filename",
      "path": "$template_package",
      "content_type": "application/gzip",
      "size": $package_size
    },
    {
      "name": "$template_filename.sha256",
      "path": "${template_package}.sha256",
      "content_type": "text/plain",
      "size": $(stat -c%s "${template_package}.sha256")
    }
  ]
}
EOF
    
    log_info "发布信息文件: $release_info"
}

# 清理临时文件
cleanup_temp_files() {
    log_info "清理临时文件"
    
    rm -rf "${OUTPUT_DIR}/temp"
    
    log_info "临时文件清理完成"
}

# 验证模板包
verify_template_package() {
    log_info "验证模板包"
    
    local template_filename="${TEMPLATE_NAME}-${TEMPLATE_VERSION}-${ARCHITECTURE}.tar.gz"
    local template_package="${OUTPUT_DIR}/$template_filename"
    
    if [[ ! -f "$template_package" ]]; then
        error_exit "模板包不存在: $template_package"
    fi
    
    # 验证压缩包完整性
    if ! tar -tzf "$template_package" >/dev/null 2>&1; then
        error_exit "模板包损坏或格式错误"
    fi
    
    # 验证必要文件存在
    local required_files=("rootfs.tar.gz" "config" "template" "manifest.json")
    for file in "${required_files[@]}"; do
        if ! tar -tzf "$template_package" | grep -q "^$file$"; then
            error_exit "模板包中缺少必要文件: $file"
        fi
    done
    
    # 验证校验和
    if [[ -f "${template_package}.sha256" ]]; then
        if sha256sum -c "${template_package}.sha256" >/dev/null 2>&1; then
            log_info "✓ 校验和验证通过"
        else
            error_exit "校验和验证失败"
        fi
    fi
    
    log_info "✓ 模板包验证通过"
}

# 生成打包报告
generate_package_report() {
    local report_file="${OUTPUT_DIR}/package-report.txt"
    local template_filename="${TEMPLATE_NAME}-${TEMPLATE_VERSION}-${ARCHITECTURE}.tar.gz"
    local template_package="${OUTPUT_DIR}/$template_filename"
    
    log_info "生成打包报告: $report_file"
    
    cat > "$report_file" << EOF
# PVE LXC K3s Template Package Report

## Package Information
Package Date: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
Package Host: $(hostname)
Package User: $(whoami)
Output Directory: $OUTPUT_DIR

## Template Information
Template Name: $TEMPLATE_NAME
Template Version: $TEMPLATE_VERSION
Template Description: $TEMPLATE_DESCRIPTION
Template Author: $TEMPLATE_AUTHOR
Architecture: $ARCHITECTURE
K3s Version: $K3S_VERSION

## Package Files
Template Package: $template_filename
Package Size: $(numfmt --to=iec $(stat -c%s "$template_package"))
Checksum File: $template_filename.sha256
Release Info: release-info.json
Package Report: package-report.txt

## Package Contents
$(tar -tzf "$template_package" | sed 's/^/  /')

## Checksums
$(cat "${template_package}.sha256")

## Package Statistics
Total Package Time: $((SECONDS / 60)) minutes $((SECONDS % 60)) seconds
Compression Ratio: $(tar -tzf "$template_package" | wc -l) files packaged

## Installation Command
pct create <VMID> local:vztmpl/$template_filename

## Next Steps
1. Test template deployment in PVE environment
2. Upload to GitHub releases
3. Update documentation and changelog

EOF
    
    log_info "打包报告生成完成"
}

# 主打包函数
main() {
    local start_time=$SECONDS
    
    log_info "=========================================="
    log_info "PVE LXC K3s Template Packager 开始打包"
    log_info "=========================================="
    
    # 执行打包步骤
    load_configuration
    verify_build_output
    
    # 创建临时目录
    mkdir -p "${OUTPUT_DIR}/temp"
    
    create_template_metadata
    create_rootfs_archive
    calculate_checksums
    create_template_package
    generate_release_info
    verify_template_package
    cleanup_temp_files
    
    # 生成报告
    generate_package_report
    
    local package_time=$((SECONDS - start_time))
    log_info "打包成功完成"
    log_info "总打包时间: $((package_time / 60)) 分钟 $((package_time % 60)) 秒"
    log_info "输出目录: $OUTPUT_DIR"
    
    return 0
}

# 显示帮助信息
show_help() {
    cat << EOF
PVE LXC K3s Template Packager

用法: $0 [选项] [命令]

命令:
    package             打包模板 (默认)
    verify              验证现有模板包
    info                显示模板信息
    clean               清理输出目录

选项:
    --config FILE       指定配置文件路径 (默认: config/template.yaml)
    --build-dir DIR     指定构建目录 (默认: .build)
    --output-dir DIR    指定输出目录 (默认: output)
    --debug             启用调试输出
    --help              显示此帮助信息

环境变量:
    DEBUG=true          启用调试输出

示例:
    # 打包模板
    $0 package
    
    # 验证模板包
    $0 verify
    
    # 启用调试模式打包
    $0 --debug package
    
    # 使用自定义配置文件
    $0 --config /path/to/config.yaml package

EOF
}

# 解析命令行参数
parse_arguments() {
    local command="package"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            package|verify|info|clean)
                command="$1"
                shift
                ;;
            --config)
                CONFIG_FILE="$2"
                shift 2
                ;;
            --build-dir)
                BUILD_DIR="$2"
                shift 2
                ;;
            --output-dir)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            --debug)
                export DEBUG=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                log_error "未知选项: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # 执行命令
    case $command in
        package)
            main
            ;;
        verify)
            load_configuration
            verify_template_package
            ;;
        info)
            load_configuration
            log_info "模板信息:"
            log_info "  名称: $TEMPLATE_NAME"
            log_info "  版本: $TEMPLATE_VERSION"
            log_info "  架构: $ARCHITECTURE"
            log_info "  K3s版本: $K3S_VERSION"
            ;;
        clean)
            log_info "清理输出目录: $OUTPUT_DIR"
            rm -rf "$OUTPUT_DIR"/*
            log_info "清理完成"
            ;;
    esac
}

# 脚本入口点
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    parse_arguments "$@"
fi